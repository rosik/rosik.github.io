## 1. Тезисы

------

Lua - простой язык. Базовые вещи можно выучить минут за 20 без
преувеличения. Но несмотря на всю свою простоту, Lua всё-таки может
преподнести сюрприз неопытному разработчику. А чтобы писать хороший код,
хорошо бы понимать, что происходит за кулисами.

Одна из причин простоты языка заключается в том, что в Lua есть всего
один композитный тип данных - таблицы. Таблицы призваны подойти для
любых целей - их можно использовать и как массив (если ключи
целочисленные), и как key-value-хранилище. А еще таблицам присуще
свойство undefined behavior - о нем и рассказ:

- Для массивов с "дырками" не определено свойство длины, на результат
  может влиять внутреннее представление и фаза Луны.

- Добавление новых элементов во время итерирования может нарушить
  порядок итерации.

- Порядок итерации `pairs()` не детерминирован даже для массивов.

Доклад полон примеров, отсылкам к стандарту и объяснениями причин. Но
даже "опасный" код может работать без сюрпризов, главное - знать, когда
на это можно рассчитывать.

------


## 2. Фактура

- У нас есть Тарантул и есть луа, в луа есть таблицы.
- Таблицей можно пользоваться как массивом `{1, 2, 3}`.
- Таблицей можно пользоваться как key-value `{apple = "red", carrot = "orange"}`.
- Вы можете придумать более оптимальный паттерн для своей задачи.
- Пока вы думаете над оптимизацией главное чтобы паттерн вообще не оказался нерабочим.

- Начнем с простого и поговорим о массивах и об их длине, что же может пойти не так.
- `#{} == 0`
- `#{1, 2, 3} == 3`
- `t = {}; t[28] = 'z'; #t == ?`

Почему так? Давайте посмотрим на внутреннее устройство.
Есть два региона памяти - массив и key-value.

Логика размещения в той или в другой части сложная, про нее не расскажу.
А ещё есть рехешинг, про него расскажу, но позже.
Вернемся к примерам. Почему третий пример так себя ведет, что реально лежит в памяти.
две таблицы могут содержать одни и те же ключи и значения, но отличаться внутренним представлением.
Цитата из стандарта.
В том примере как он приведен `#t == 0`
Но если сделать `t = table.new(28, 0); t[28] = 'z', то #t == 28`

Это искусственные примеры. А вот два из реальной жизни.
Минутка морали. Внутреннее представление может влиять,
а может и не влиять на поведение. Оседомлен, значит вооружен.

`#{1, 2, 3} == 3` - вот этот пример не зависит от внутреннего представления,
это нам гарантирует стандарт.

Спросите себя, а что вообще должен был делать код. Может тут нужен `maxn`, а не длина `#`
Да, он дороже, но вдруг нужен именно он.

Формат презентации не предполагает лайв кодинга, поэтому поверьте мне наслово

## Кейсы

- Слабая типизация
- Большие числа
- UB в таблицах
- Возня с замыканиями
